<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icons8-coordinate-system-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icons8-coordinate-system-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言：暑假几乎花了一整个月备考PAT，期间因为调代码调到过深夜，做模拟题也曾做的心态有点奔溃，但总的来说这一段时间过的是很充实的，感觉自己的代码能力确实有提高不少，今年秋季PAT出的题都比较常规，侥幸拿了个满分（感谢姥姥手下留情），不过拿了满分后也并没有想象中的那样激动，更多的是一种怅然若失的感觉和冥冥中一种遗憾，我也说不清这种遗憾究竟是什么，感觉PAT也只是自己学习的长途中一个小的结点，它从某">
<meta property="og:type" content="article">
<meta property="og:title" content="notes_for_pat">
<meta property="og:url" content="http://example.com/2021/09/11/notes-for-pat/index.html">
<meta property="og:site_name" content="Vincent&#39;s blog">
<meta property="og:description" content="前言：暑假几乎花了一整个月备考PAT，期间因为调代码调到过深夜，做模拟题也曾做的心态有点奔溃，但总的来说这一段时间过的是很充实的，感觉自己的代码能力确实有提高不少，今年秋季PAT出的题都比较常规，侥幸拿了个满分（感谢姥姥手下留情），不过拿了满分后也并没有想象中的那样激动，更多的是一种怅然若失的感觉和冥冥中一种遗憾，我也说不清这种遗憾究竟是什么，感觉PAT也只是自己学习的长途中一个小的结点，它从某">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-11T13:55:37.000Z">
<meta property="article:modified_time" content="2022-01-03T12:02:39.379Z">
<meta property="article:author" content="Vincent-luo">
<meta property="article:tag" content="PAT">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/09/11/notes-for-pat/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>notes_for_pat | Vincent's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vincent's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/11/notes-for-pat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_1.jpg">
      <meta itemprop="name" content="Vincent-luo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincent's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          notes_for_pat
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-11 21:55:37" itemprop="dateCreated datePublished" datetime="2021-09-11T21:55:37+08:00">2021-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-03 20:02:39" itemprop="dateModified" datetime="2022-01-03T20:02:39+08:00">2022-01-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>前言：暑假几乎花了一整个月备考PAT，期间因为调代码调到过深夜，做模拟题也曾做的心态有点奔溃，但总的来说这一段时间过的是很充实的，感觉自己的代码能力确实有提高不少，今年秋季PAT出的题都比较常规，侥幸拿了个满分（感谢姥姥手下留情），不过拿了满分后也并没有想象中的那样激动，更多的是一种怅然若失的感觉和冥冥中一种遗憾，我也说不清这种遗憾究竟是什么，感觉PAT也只是自己学习的长途中一个小的结点，它从某个角度上证明了前期努力的成果，但是它远不能成为对自己能力的炫耀，因为我知道自己能力还是有很多不足之处的，我觉得可以做到更好，这无疑需要更长期的努力。我愿把这次PAT考试作为一个新的起点，以此出发开始一段新的旅途，因为我觉得后面的风景会更美……</p>
<p>这篇文章是备考PAT过程中的一些笔记，记录下来作为一个纪念吧哈哈哈哈</p>
</blockquote>
<span id="more"></span>
<h2 id="string相关"><a href="#string相关" class="headerlink" title="string相关"></a>string相关</h2><ul>
<li><p><code>substr(pos,len)</code>函数返回从pos下标开始，长度为len的子串</p>
</li>
<li><p>string类型的转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">str.<span class="built_in">c_str</span>();  <span class="comment">//string转换成char[]</span></span><br><span class="line"><span class="built_in">to_string</span>(i); <span class="comment">//int转化为string</span></span><br><span class="line"><span class="built_in">stoi</span>(str);  <span class="comment">//string转int方法一 C++11</span></span><br><span class="line"><span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>()); <span class="comment">//string转int方法二</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大小写转换，<code>tolower()</code>函数和<code>toupper()</code>函数，函数在头文件<code>cctype</code>中</p>
</li>
<li><p><strong>string相关函数总结</strong></p>
<blockquote>
<ul>
<li><p>insert(pos, string) 在pos号位插入string字符串 <strong>（下标定位）</strong></p>
</li>
<li><p>insert(it, it2, it3) it为与插入位置，it2，it3为待插入字符串首尾迭代器，将串[it2, it3)插入到it的位置上<strong>（迭代器定位）</strong></p>
</li>
<li><p>erase(it) 删除it迭代器位置的元素（删除单个元素）</p>
</li>
<li>erase(first, second) 删除[first, second)区间元素，first和second为迭代器</li>
<li><p>erase(pos,length) pos为删除起始位置，length为删除的个数</p>
</li>
<li><p>substr(pos, lenth) pos位开始，长度为length的子串</p>
</li>
<li><p>string::npos  可以作为find函数失败时的返回值</p>
</li>
<li><p>str.find(str2,pos) 返回子串str2在str中第一次出现的位置，若没有子串str2返回string::npos, pos可以加也可以不加，加上后表示从pos号位开始查询</p>
</li>
<li><p>str.repalce(pos, len,str2) 将str从pos位开始长度为len的子串替换为str2</p>
</li>
<li>str.replace(it1,it2,str2) 将子串[it1,it2)替换为str2</li>
</ul>
</blockquote>
</li>
<li><p>string读取一行 getline(cin, str);</p>
</li>
<li><p><strong>getline读取一行数据时一定要先把上一行的换行符去掉！！！</strong></p>
</li>
<li><p><code>cin.ignore()</code> 默认可以跳过一个字符</p>
</li>
</ul>
<h2 id="map相关"><a href="#map相关" class="headerlink" title="map相关"></a>map相关</h2><ul>
<li><code>map&lt;string,int&gt;</code>和<code>unordered_map&lt;string,int&gt;</code> int的<strong>默认值为0</strong></li>
<li>hash数组能将所有元素的查询降到O(1), 使用map虽然能节省一定的空间，但是<strong>查询不在map中的元素是需要一定时间的</strong></li>
</ul>
<h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><ul>
<li><p><code>gets(char* )</code>读取一行字符串</p>
</li>
<li><p><code>scanf(&quot;%c&quot;, &amp;a)</code>是<strong>可以读入空格和换行的</strong>，输入的时候要注意</p>
</li>
<li><p><code>sscanf(str,&quot;%d&quot;,&amp;n)</code> 将字符串数组str中的内容以%d的格式写入n中</p>
<p><code>sprintf(str,&quot;%d&quot;,n)</code> 将n以%d的格式写入str字符串数组中</p>
</li>
<li><p>处理字符数组的函数（均在头文件string.h中，<strong>string.h</strong>和<strong>string</strong>是不一样的头文件）</p>
<blockquote>
<p><strong>strlen(字符数组)</strong> 返回字符串数组以一个’\0’前的字符个数，也即是字符串的长度</p>
<p><strong>strcmp(字符数组1，字符数组2)</strong> 返回数组<strong>字典序</strong>比较结果，str1&gt;str2返回正整数，str1=str2返回0，str1&lt;str2返回负整数</p>
<p><strong>strcpy(字符数组1，字符数组2)</strong> 将str2复制给str1</p>
<p><strong>strcat(字符数组1，字符数组2)</strong> 将str2接到str1后面</p>
</blockquote>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>链表节点结构体中可以添加<strong>address记录节点地址</strong>、<strong>num记录节点在链表中的次序</strong>、以及<strong>flag表示节点某种性质</strong>，一般的题可以通过num和flag的综合排序解决，当然也可以单独用一个vector容器存储特定性质的节点序列最后输出</li>
</ul>
<h2 id="DFS和BFS"><a href="#DFS和BFS" class="headerlink" title="DFS和BFS"></a>DFS和BFS</h2><ul>
<li><p><strong>剪枝</strong>的两种方式：</p>
<p>①在进入新的“分支”前进行判断，以决定是否进入新分支；</p>
<p>②直接判断当前的状态是否以及不合题意，直接return；</p>
<p>这两种的区别在于第一种只产生所有合乎题意的“路径”，而第二种可能比合乎题意的“路径”多向下走了一层</p>
</li>
<li><p>从一个序列中枚举所有子列或是从N个数中选择K个数，枚举的一般思路是依次判断<u>原序列中的所有数<strong>选</strong>还是<strong>不选</strong></u></p>
</li>
<li><p><strong>BFS要点</strong>：①首元素出队的时候进行访问（所以只需将遍历的相关信息存在队列中就可以了）；②在元素入队时记录遍历层数；③inq数组记录结点是否入队</p>
</li>
<li><p>有一些贪心问题用DFS解决时，往往是<strong>不需要遍历</strong>的，除非涉及到一些比较复杂的指标，所以一般要根据贪心的策略去“剪枝”。</p>
</li>
<li><p><strong>在“判断”是否要剪枝的时候最好不要改变该记录该递归状态下的状态量</strong>，因为改变后还需要重新复原后才能返回，否则状态量的记录就不对了，所以比较好的做法时，判断的时候不改变，确定需要向下递归时再去改变。</p>
</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul>
<li>图的深度优先遍历需要<strong>vis[]数组</strong>记录结点是否访问过，广度优先遍历需要<strong>inq[]数组</strong>记录结点是否入队，迪杰斯特拉算法需要<strong>vis[]数组</strong>记录节点是否已被加入集合S中。</li>
<li>由于<strong>非连通图的存在</strong>，除了DFS()函数或BFS()函数外还需要DFSTrave()函数和BFSTrave()函数，保证遍历到图中所有结点。</li>
</ul>
<h2 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h2><ul>
<li><p><strong>进制转换</strong>：将十进制数 y 转化为Q进制，每次将 y 除 Q 的余数保存到<strong>数组 z[]</strong> 中，最后将 z 数组逆序输出；注意，<strong>循环最好用</strong><code>do&#123;&#125;while()</code> ，否则当 y 为0的时候可以会直接跳出，z[] 中将不会有元素</p>
</li>
<li><p>素数表的建立 <code>int prime[maxn],num=0</code> 表长maxn至少比n（要输出的最大范围）大1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//素数筛</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            prime[num++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)</span><br><span class="line">            &#123;</span><br><span class="line">                p[j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>质因数分解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用结构体数组存储质因子</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factor</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,cnt;</span><br><span class="line">&#125;fac[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//数组大小开到10就可以处理int范围内的值了</span></span><br><span class="line"><span class="comment">//因为2*3*5*7*11*13*17*19*23*29已经超过int最大值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分数的计算，用一个结构体存储分数，注意分数的化简当分子为0时将分母置为1，方便作为整数输出，其他情形将分子分母约分就可以了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> up,down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>大整数</p>
<p>①大整数可以使用结构体存储，如下所示，但是由于运算时总是从整数低位到整数高位进行枚举，所以为了方便，结构体中<strong>数组低位存储整数高位</strong>，直观上看就是带过来存储。当然<strong>用string存储也是可以的</strong>，有时候做题显得更简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②大整数运算——将运算步骤转化为代码</p>
<ul>
<li>加法：从低位依次枚举，<strong>和的个位赋给结果的相应位</strong>，<strong>十位为下一位的进位</strong>，枚举完毕后若进位carry不为零，将其赋给结果最高位</li>
<li>减法：进行减法前要判断，将较大的数作为被减数。从低位依次枚举，若<strong>不够减被减数高位减一，被减位加十后再减</strong>。结果<strong>高位可能有0，要将其删除</strong>。</li>
<li>乘法：这里仅考虑高精度乘以低精度，将<strong>低精度（如int）作为整体</strong>，从低位枚举大整数，个位数为结果对应位，高位为进位（可能有多位）。最后进位若不为0，依次赋给高位（可能有多位）。</li>
<li>除法：这里仅考虑高精度除低精度。<strong>除法的结果是高位先得出</strong>，从大整数<strong>高位开始枚举</strong>，不够除商0；够除得到相应的除数和余数，再将<strong>余数乘10加上下一位作为下一步临时的被除数</strong>，最后高位同样可能有0，要去除。</li>
</ul>
</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li>分治是一种算法思想，其核心在于将问题<strong>分解成与原问题相同和相似的子问题</strong>，缩小问题规模直到能求解，<strong>递归只是它的一种实现方式，两者并不等同</strong></li>
<li>递归是一种程序实现方式，其特点在于反复调用自身函数，如果<strong>求解问题中有反复出现的相同相似求解过程</strong>，那么递归是一种很好的实现方式。分治之所以可以用递归实现是因为有结构相同或相似的子问题，但是递归能解决的问题会更广泛，凡是有反复出现类似的求解过程都可以考虑使用递归函数。</li>
<li>递归函数的参数表用来记录当前递归解决的问题或是递归状态。</li>
</ul>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><ul>
<li><p>二分法的实现很简单，给定查询区间<code>[left,right]</code>，每次根据中心点<code>mid=(left+right)</code>处的值与查询值的大小关系更新left和right就可以了，循环的条件是<code>left&lt;=right</code>，即<code>left&gt;right</code>时跳出，此时查询失败</p>
</li>
<li><p>寻找第一个大于等于x的元素A[y]，A[y]一定满足：<strong>A[y]&gt;=x&gt;A[y-1]</strong>，故A[mid]&gt;=x时 A[mid]&gt;=x&gt;A[y-1]⇨ mid&gt;y-1⇨mid&gt;=y⇨向区间[left,<strong>mid</strong>]查询；当A[mid]&lt;x同理可得到向区间[<strong>mid+1</strong>,right]查询。</p>
<p>并且还要注意：①<strong>循环条件为left&lt;right</strong>，因为即使查询失败也要返回“假设它存在，它应该在的位置”；②由于查询元素可能比序列中所有元素要大，故<strong>传入函数的初值right应该比序列上界大1</strong>，即传入[left,right]=[0,n]。</p>
</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>归并排序递归实现：对一个序列进行递归排序，只需要分别对其左右两个区间分别进行递归排序，然后将其合并，注意左右两个区间是[left, mid]，[mid+1, right]，其中mid=(left+right)/2，递归边界为left=right，即为一个元素时，或者可以写left&lt;right时继续向下递归</li>
<li>归并排序非递归实现：设置step初始值为2，每次循环将step个元素分为一组，将前step/2个元素和后step/2个元素合并，注意组内元素少于step/2时不需要合并，每次循环完成后step乘2。循环的条件是当前step/2&lt;n(n为序列元素个数)。</li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li>若给定BST所有结点的值（均不相同）和BST的结构是可以唯一建立一颗BST的，有两种思想可以考虑：①二叉搜索树的中序遍历序列是递增序列，所以可以中序遍历树结构，将<strong>要输出中序遍历序列的语句改成给相应根节点赋值</strong>，这样就建立了这棵树。②先遍历一遍树，求以每个节点为根节点的子树的结点数，在过程中<strong>将每个结点的左子树的结点树记录下来</strong>；若某个结点左子树结点树为numLeft, 则它对应的值为序列中第numLeft+1大的那个数</li>
<li>由于AVL数需要计算平衡因子，方便起见在结点结构体中加入<strong>height</strong>，记录以某个结点为根节点的子树的高度，<strong>对树的结构进行改变时要更新高度</strong>。左旋右旋操作均需要有更新高度的操作。</li>
</ul>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul>
<li>并查集是一种维护集合的数据结构，<strong>很好地表示了集合这种抽象概念</strong>，所以可以运用到涉及划分群体和分类的题中，其中最重要的就是合并操作，就是将属于同一个集合的元素合并，题目中最核心的往往在于如何判断两个元素属于同一集合，有的题目会直接给出属于同一集合的条件，但有些则需要判断再合并。</li>
<li>对于将某个性质相同的元素进行合并的题目，可以记录第一个出现该性质的元素下标，将后序所有该性质的元素直接与记录的元素合并就可以了，这样可以避免反复遍历查询。</li>
</ul>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><ul>
<li>Bellman-Ford算法不需要<code>vis[]</code>数组，它总共进行<code>V-1</code>轮操作，每一轮操作都遍历所有的边，判断是否有能被更新的距离，时间复杂度为O(VE)。唯一与dijkstra算法不同的一点在于<strong>统计最短路径条数的做法</strong>，因为DF算法会多次访问已经访问过的结点，为了解决这个问题可以设置一个<strong>set\<int\> pre[maxn]</strong> 来存储前驱节点，当<strong>遇到与已有最短路径相同长度的路径是需要重新计算最短路径条数</strong>。</li>
<li>SPFA算法是使用队列优化了BF算法，因为<strong>只有某个顶点u的d[u]改变时，从它出发的边的邻接点v的d[v]值才有可能被改变</strong>，所以每次都将改变过的结点入队，去看看以这些点为中介点能否优化其他路径。实现过程中有几点要注意，①要设置一个inq[]数组，记录<strong>“当前状态”在队列中结点</strong>，因为如果结点已经在队列中的话就不需要反复入队了；②设置num[]数组，记录结点入队次数，如果某个<strong>结点入队次数超过n-1次说明图中有负环</strong></li>
<li>另外SPFA算法和BF算法最好用邻接表实现，这样效率更好。SPFA算法也比朴素dijkstra算法快很多，据算法笔记上说，它甚至经常性优于堆优化的dijkstra算法。</li>
<li>Floyd算法的流程：枚举所有的顶点，如果以它为中介点能让其他两点间的距离缩小则更新这个最短距离。Floyd算法实现很简单只需要一个二维数组dis[maxn][maxn]即可。</li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul>
<li>拓扑排序的实现：首先需要一个记录入度的数组<code>inDegree[]</code>，先将所有入度为0的结点入队，只要队列不为空，每次取出队首元素，将其能到达的结点入度减一，如果入度变为0，则将其也入队。拓扑排序也可以用于判断图是否为有向无环图，只需要记录入过队的结点总数num，当队列为空时，如果num等于结点总数</li>
</ul>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><ul>
<li>一个活动最早开始时间等于左端点事件最早发生事件，最迟发生事件等于右端点事件最迟发生时间减边权</li>
<li>ve[]初始化为0，vl初始化为ve[]最大最</li>
<li>最后遍历所有边（活动）确定关键路径</li>
</ul>
<h2 id="怎么写循环"><a href="#怎么写循环" class="headerlink" title="怎么写循环"></a>怎么写循环</h2><blockquote>
<p>在考试中循环语句往往是比较容易写错或是比较难写的，这里专门用一个小节来总结一下程序里面“<strong>循环怎么写</strong>”</p>
</blockquote>
<ul>
<li>循环是对一系列<strong>不同对象进行相同或相似操作的结构</strong>。</li>
<li>循环条件不好写的可以用<code>while(1)</code>和<code>break</code>控制</li>
<li>循环只能解决<strong>一个</strong>状态向下转变为另<strong>一个</strong>状态的搜索，如果对应多个状态，请用DFS！！！</li>
<li>要写的循环是什么，怎么更新变量进入下一个循环，循环什么时候跳出。</li>
<li>对于要枚举一系列值直接用for循环</li>
</ul>
<h2 id="PAT考试"><a href="#PAT考试" class="headerlink" title="PAT考试"></a>PAT考试</h2><ul>
<li>考试中遇到bug是很正常的事，要知道<strong>bug的出现都是有缘由</strong>的，<strong>通过调试观察程序执行的效果和预想的有没有差异，找到出错点改正就可以了</strong>。bug也没那么可怕，不要被自己的心态打败了！</li>
<li>找不到原因的时候看看是否由输出错误，这是OJ特有的错误！</li>
<li>分析问题，先确定整体的<strong>问题解决思路</strong>，明确<strong>具体的解决步骤</strong>，然后将其<strong>转化为程序语言</strong>去执行</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li><p><strong>变量名最好有一定的意义</strong>，这样在代码编写过程中不容易出现张冠李戴的情况</p>
</li>
<li><p><strong>至少循环一次的写法</strong>:</p>
<p>1.<code>do&#123;&#125;while()</code>语句</p>
<p>2.<code>while(1)&#123;&#125;</code>在循环体中加入<code>break</code>语句控制什么时候跳出</p>
</li>
<li><p><code>while(scanf(&quot;%d&quot;,&amp;n) != EOF)&#123;&#125;</code>表示直到没有输入为止停止循环，另外在终端中输入<ctrl+Z>和回车键表示EOF</p>
</li>
<li><p>不要用<strong>循环中会改变的量</strong>初始某个变量，最好在循环外面将初始值单独存下来</p>
<p>使用<code>while</code>循环的时候注意<strong>更新变量</strong></p>
<p>注意循环中有些变量每次循环开始时要<strong>初始化</strong></p>
</li>
<li><p>编写程序过程中，一定要清楚<strong>变量的含义和存储的数据情况</strong>，要不然也会出现弄错下标的情况；另外<strong>数据的类型</strong>也很重要 </p>
<p>:star2:编程的<strong>逻辑（思路）</strong>清晰是第一步，然后如何把它<strong>转化成程序语言</strong>也很重要——其中要注意的是①语句的顺序很重要，程序是顺序执行的，一定要考虑顺序对执行效果的影响，以及顺序执行的效果与解决问题的方法是不是对应的:star2:</p>
</li>
<li><p><strong>质数</strong>判断<strong>不要漏掉0和1</strong>，要单独判断</p>
</li>
<li><p>注意题目的编号，是<strong>1~n</strong>还是<strong>0~n-1</strong>, 最好把<strong>相应的数组也与编号对应起来</strong>，这样不容易出错！！</p>
</li>
<li><p><strong>段错误</strong>的原因是跟内存相关的，往往出错的原因是数组开的长度过小或是指针越界等</p>
</li>
<li><p><strong>部分测试点的错误</strong>要考虑边界情况，即使觉得不太可能也要试一试，可能就是老师挖的坑！！！</p>
</li>
<li><p>string使用+=更快一些</p>
</li>
<li><p>能模拟到底就尽量模拟到底，这样能省去很多推理的过程，也减少了出错的可能。</p>
</li>
<li><p><strong>set</strong>的主要作用有<strong>自动去重和按升序排列</strong>，在某些情况下查找的效率是比较高的（可以解决一些超时问题），涉及排序的题可以考虑使用</p>
<p>另外对于结构体，可以通过通过重载小于号<code>&lt;</code>使得set中元素按照需要的顺序排列，一种实现方式是使用友元函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//其他部分省略</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Node a,Node b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vector</code>的最后一个元素下标是<code>vector.size()-1</code>，<strong>不要访问越界了</strong>！</p>
</li>
<li><p><strong>判断是不是完全⼆叉树</strong>，就看在出现了⼀个孩⼦为空的结点之后是否还会出现孩⼦结点不为空的结点，如果出现了就不是完全⼆叉树。</p>
</li>
<li><p>在涉及“<strong>图</strong>”的题目中，若结点标识为字符串需要用hash的方法或是使用<code>map&lt;string,int&gt;</code>将其转化为int型的数字，这样才能构建邻接矩阵或是邻接表</p>
</li>
<li><p>要<strong>计算某个连通图的总边权</strong>时，在DFS中要判断该节点与<strong>其他所有节点</strong>之间是否有通路，有的话就累加起来，然后删掉这条边避免重复计算。</p>
</li>
<li><p><strong>审题很重要！很重要！很重要！</strong> <strong>明确题目中字母的含义</strong>(n,k,…), 不要因为做题惯性就把它当作其他值了，例如并不是所有的n都是图的节点个数的；开始写代码之前最好有<strong>将实际问题抽象成数据结构的过程</strong>，这样可以减少编码是的错误</p>
</li>
<li><p>初始化邻接矩阵使用fill函数时，<strong>首地址是G[0]</strong></p>
</li>
<li><p>检查代码错误的时候，也要时刻提醒自己代码是顺序执行的，前面的语句时会对后面语句的执行效果或是某些变量的值造成改变的，所以<strong>初始化是很重要的</strong></p>
<p>:star2:迪杰斯特拉最短路径问题记得初始化<code>G[maxn][maxn]</code>!!!!!:star2:</p>
</li>
<li><p>对于某些问题不要想当然，最好去<strong>一步步模拟一遍</strong></p>
</li>
<li><p>有些<strong>空格的输出可以单独输出</strong>，可能会比连带其他内容一起输入时更好控制</p>
</li>
<li><p><strong>int型变量不赋初值可能是一个很大的数</strong>，有时候会直接超出数组范围引起段错误</p>
</li>
<li><p>对于一些稍复杂的题，<strong>先理清思路，明确要处理数据的情况以及相应的处理方式</strong>，确定算法步骤<strong>再转化成程序语言</strong>就可以了！</p>
</li>
<li><p>写程序是尽量做到<strong>对各种数据处理的全面性</strong>，不要认为测试数据就都是正常的，<strong>对不正常的数据要做判断或是筛除</strong>，确保程序是正确的，要不然可能就正好遇到老师挖好的坑了</p>
<blockquote>
<p><strong>怎么debug</strong>：①第一个层次：检查每条语句是否与实现的方法相符；②第二个层次：明确要解决什么问题以及<strong>要怎么实现</strong>，由此<strong>代码该怎么写</strong>（逻辑层面）③一些tips，注意一些边界情况能不能同样得到处理，<strong>全面考虑所有的情况</strong>，特别是有一些边界情况因为与大多数不同而没法满足判断条件进入相应的代码块导致逻辑错误 ④如果始终找不到错误可以重新审题考虑是不是忽略了一些隐含条件。⑤考试中要检查是否有打错的情况！！！</p>
</blockquote>
</li>
<li><p>bool型数组如果这样赋值<code>bool vis[maxn]=&#123;true&#125;</code><strong>只有第一个元素被赋值成true！！！</strong> 但是false可以赋给每一个值</p>
</li>
<li><p>遍历可以一次遍历所有的”连通块“，计算遍历的次数可以知道连通块的数量。</p>
</li>
<li><p>随机数生成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要包含stdlib和time头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>   <span class="comment">//可以替换成cstdlib</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span>    <span class="comment">//可以替换成ctime</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));  <span class="comment">//生成随机数种子</span></span><br><span class="line">    <span class="built_in">rand</span>(); <span class="comment">//生成随机数 范围[0,RAND_MAX]</span></span><br><span class="line">    <span class="built_in">rand</span>()%(a-b+<span class="number">1</span>)+b; <span class="comment">//[a,b]范围随机数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当要生成的随机数范围长度超过RAND_MAX时可以这样写</span></span><br><span class="line">    <span class="built_in">round</span>((<span class="built_in">rand</span>()*<span class="number">1.0</span>/RAND_MAX*(a-b)+b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>vector\<int>作为元素本身也是可以用sort函数直接排序的，排序默认是按照vector\<int>序列的“字典序”</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/PAT/" rel="tag"># PAT</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/02/DFS/" rel="prev" title="DFS中怎么记录当前“递归结点”的状态量">
      <i class="fa fa-chevron-left"></i> DFS中怎么记录当前“递归结点”的状态量
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/03/cs231n-lecture2/" rel="next" title="cs231n_lecture2">
      cs231n_lecture2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E7%9B%B8%E5%85%B3"><span class="nav-number">1.</span> <span class="nav-text">string相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map%E7%9B%B8%E5%85%B3"><span class="nav-number">2.</span> <span class="nav-text">map相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3"><span class="nav-number">3.</span> <span class="nav-text">字符串相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">4.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS%E5%92%8CBFS"><span class="nav-number">5.</span> <span class="nav-text">DFS和BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">6.</span> <span class="nav-text">图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">数学问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">8.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">二分法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">10.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">11.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">12.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">13.</span> <span class="nav-text">最短路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">14.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">15.</span> <span class="nav-text">关键路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%86%99%E5%BE%AA%E7%8E%AF"><span class="nav-number">16.</span> <span class="nav-text">怎么写循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PAT%E8%80%83%E8%AF%95"><span class="nav-number">17.</span> <span class="nav-text">PAT考试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%82%E9%A1%B9"><span class="nav-number">18.</span> <span class="nav-text">杂项</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vincent-luo"
      src="/images/avatar_1.jpg">
  <p class="site-author-name" itemprop="name">Vincent-luo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vincent-luo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
